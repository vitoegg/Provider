name: Update Rules

on:
  schedule:
    - cron: '0 */3 * * *'  # 每3小时执行一次
  workflow_dispatch:

env:
  RULES_CONFIG: |
    rules:
      China:
        path: RuleSet/Direct/China.list
        urls:
          - https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Surge/ChinaMax/ChinaMax_Domain.list
          - https://raw.githubusercontent.com/Loyalsoldier/surge-rules/release/direct.txt
          - https://raw.githubusercontent.com/vitoegg/Provider/master/RuleSet/Direct/LocalNet.list
      
      Apple:
        path: RuleSet/Apple/Service.list
        urls:
          - https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Surge/Apple/Apple_Domain.list
          - https://raw.githubusercontent.com/Loyalsoldier/surge-rules/release/apple.txt
          - https://raw.githubusercontent.com/Loyalsoldier/surge-rules/release/icloud.txt
      
      Reject:
        path: RuleSet/Extra/Reject.list
        urls:
          - https://ruleset.skk.moe/List/domainset/reject.conf
          - https://ruleset.skk.moe/List/domainset/reject_extra.conf
          - https://raw.githubusercontent.com/vitoegg/Provider/master/RuleSet/Extra/Privacy.list

jobs:
  update-rules:
    # 使用 Ubuntu 最新版本作为运行环境
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.check_changes.outputs.has_changes }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        # 添加日志输出
        id: checkout
        with:
          fetch-depth: 1  # 仅获取最近一次提交，加速检出过程

      - name: Setup Timezone
        run: sudo timedatectl set-timezone "Asia/Shanghai"
        # 添加日志输出
        id: timezone

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
        # 添加日志输出
        id: python

      - name: Create Processing Script
        id: create_script
        run: |
          echo "::group::创建规则处理脚本"
          echo "创建高效的规则处理脚本..."
          # 创建高效处理脚本
          cat > process_rules.sh << 'EOF'
          #!/bin/bash
          set -eo pipefail

          # ==========================================
          # 规则更新脚本 - 简化版
          # 功能：下载、清理、去重并合并网络规则
          # ==========================================

          # 解析规则配置
          # 输入：规则配置文本
          # 输出：规则设置和文件列表
          parse_rules_config() {
            local config="$1"           # 配置文本
            local -n configs_ref="$2"   # 规则配置引用
            local -n files_ref="$3"     # 文件列表引用

            local rule_name=""  # 当前规则名称
            local path=""       # 规则输出路径
            local urls=""       # 规则源URL列表

            # 逐行读取配置
            while IFS= read -r line; do
              # 跳过空行和注释
              [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

              # 匹配规则名称行
              if [[ "$line" =~ ^[[:space:]]*([^:]+):[[:space:]]*$ ]]; then
                rule_name="${BASH_REMATCH[1]}"
                if [[ "$rule_name" != "rules" ]]; then
                  path=""
                  urls=""
                fi
              # 匹配路径行
              elif [[ "$line" =~ ^[[:space:]]*path:[[:space:]]*([^[:space:]]+) ]]; then
                path="${BASH_REMATCH[1]}"
                files_ref+=("$path")  # 添加到文件列表
              # 跳过urls标记行
              elif [[ "$line" =~ ^[[:space:]]*urls:[[:space:]]*$ ]]; then
                continue
              # 匹配URL行
              elif [[ "$line" =~ ^[[:space:]]*-[[:space:]]*([^[:space:]]+) ]]; then
                urls+="${BASH_REMATCH[1]} "  # 添加URL到列表
              # 保存已完成的规则配置
              elif [[ -n "$rule_name" && -n "$path" && -n "$urls" && "$rule_name" != "rules" ]]; then
                configs_ref["$rule_name"]="$path;$urls"  # 保存为"路径;URL列表"格式
                rule_name=""
              fi
            done <<< "$config"

            # 保存最后一个规则配置
            if [[ -n "$rule_name" && -n "$path" && -n "$urls" && "$rule_name" != "rules" ]]; then
              configs_ref["$rule_name"]="$path;$urls"
            fi
          }

          # 下载并处理规则
          # 参数: 规则名称、输出路径、URL列表
          process_rule() {
            local rule_name="$1"      # 规则名称
            local output_path="$2"    # 输出文件路径
            local urls="$3"           # URL列表（空格分隔）
            
            # 创建输出目录
            local output_dir=$(dirname "$output_path")
            mkdir -p "$output_dir"
            
            echo "处理规则: $rule_name -> $output_path"
            # 记录处理时间
            TIMEFORMAT='处理用时: %R 秒'
            time (
              # === 第1步: 下载规则文件 ===
              echo "→ 开始下载规则源..."
              
              # 创建临时文件和目录
              local merged_file=$(mktemp)  # 合并后的文件
              local cleaned_file=$(mktemp) # 清理后的文件
              local tmp_dir=$(mktemp -d)   # 临时下载目录
              
              # 并行下载所有规则源
              local download_count=0
              local download_pids=()
              
              echo "::group::下载规则源"
              # 遍历并下载每个URL
              for url in $urls; do
                local tmp_file="${tmp_dir}/download_${download_count}"
                # 后台下载并显示结果
                (curl -sL --fail --connect-timeout 10 --max-time 30 "$url" > "$tmp_file" && 
                 echo "  ✓ 下载成功: $url" || 
                 echo "  ✗ 下载失败: $url") &
                download_pids+=($!)
                download_count=$((download_count + 1))
              done
              
              # 等待所有下载完成
              for pid in "${download_pids[@]}"; do
                wait $pid
              done
              echo "::endgroup::"
              
              # === 第2步: 合并和清理规则 ===
              echo "::group::合并和清理规则"
              echo "→ 合并下载的规则文件..."
              
              # 合并所有下载的文件
              cat "${tmp_dir}"/download_* > "$merged_file"
              
              echo "→ 清理规则..."
              # 执行规则清理:
              # 1. 删除各种格式的注释
              # 2. 删除空白行和空格
              # 3. 确保格式统一
              sed -e 's/[[:space:]]*[#;\/\/].*$//' \
                  -e 's/^[[:space:]]*//;s/[[:space:]]*$//' \
                  -e '/^$/d' \
                  -e '/^[[:space:]]*[#;\/\/]/d' \
                  -e '/^payload:/d' \
                  -e '/^[[:space:]]*\/\*/d;/\*\//d' \
                  "$merged_file" > "$cleaned_file"
              
              # 统计清理后的规则数
              local input_count=$(wc -l < "$cleaned_file")
              echo "→ 清理后规则数: $input_count"
              echo "::endgroup::"
              
              # === 第3步: 排序和去重 ===
              # 只有当有内容时才继续处理
              if [[ -s "$cleaned_file" ]]; then
                echo "::group::排序和去重"
                echo "→ 对规则排序并去重..."
                
                # 创建临时文件
                local final_file=$(mktemp)
                
                # 执行排序和去重
                sort -u "$cleaned_file" > "$final_file"
                
                # 统计结果
                local final_count=$(wc -l < "$final_file")
                local removed_count=$((input_count - final_count))
                echo "→ 去重后规则数: $final_count (减少了 $removed_count 条重复规则)"
                echo "::endgroup::"
                
                # === 第4步: 添加元数据并保存 ===
                echo "::group::生成最终规则文件"
                # 创建带有元数据的版本
                local meta_file=$(mktemp)
                
                # 添加元数据
                {
                  echo "# 规则来源:"
                  for url in $urls; do
                    # 转换为GitHub仓库URL显示
                    repo_url=$(echo "$url" | sed -E 's|raw.githubusercontent.com/([^/]+/[^/]+).*|github.com/\1|')
                    echo "# - https://$repo_url"
                  done
                  echo ""
                  # 添加规则内容
                  cat "$final_file"
                } > "$meta_file"
                
                # === 第5步: 检查是否有更改 ===
                local changed=0
                if [ -f "$output_path" ]; then
                  # 比较旧文件和新文件(忽略更新时间)
                  local old_file=$(mktemp)
                  grep -v "^# Update time:" "$output_path" > "$old_file"
                  
                  if ! cmp -s "$old_file" "$meta_file"; then
                    changed=1  # 文件有变化
                  fi
                  rm -f "$old_file"
                else
                  changed=1  # 文件不存在,需要创建
                fi
                
                # 如果有更改，写入新文件
                if [ $changed -eq 1 ]; then
                  {
                    echo "# Update time: $(date '+%Y-%m-%d %H:%M:%S')"
                    cat "$meta_file"
                  } > "$output_path"
                  echo "→ 规则已更新"
                else
                  echo "→ 规则无变化"
                fi
                echo "::endgroup::"
                
                # 清理临时文件
                rm -f "$final_file" "$meta_file"
              else
                echo "警告: $rule_name 没有有效内容"
              fi
              
              # 删除所有临时文件
              rm -f "$merged_file" "$cleaned_file"
              rm -rf "$tmp_dir"
            )
          }

          # 主函数 - 控制整个处理流程
          main() {
            local config="$1"  # 规则配置
            
            # 初始化数据结构
            declare -A rule_configs  # 关联数组: 规则名称 -> 配置
            declare -a rule_files    # 数组: 所有规则文件路径
            
            echo "→ 解析规则配置..."
            parse_rules_config "$config" rule_configs rule_files
            
            echo "======================================"
            echo "开始更新规则 ($(date '+%Y-%m-%d %H:%M:%S'))"
            echo "======================================"
            
            # 记录开始时间
            local start_time=$SECONDS
            
            # 处理每个规则
            echo "→ 发现 ${#rule_configs[@]} 个规则集"
            for rule_name in "${!rule_configs[@]}"; do
              # 解析配置字符串: 路径和URL
              IFS=';' read -r output_path urls <<< "${rule_configs[$rule_name]}"
              echo "======================================"
              # 调用处理函数
              process_rule "$rule_name" "$output_path" "$urls"
              echo "======================================"
            done
            
            # 计算总耗时
            local duration=$((SECONDS - start_time))
            echo "→ 处理完成，总用时: $((duration / 60))分$((duration % 60))秒"
            
            # 检测是否有变化
            local changes=false
            
            # 添加文件到Git以检测变化
            git add "${rule_files[@]}" 2>/dev/null || true
            
            # 检查每个文件是否有实质变化
            for file in "${rule_files[@]}"; do
              if [ -f "$file" ] && git diff --cached --no-color "$file" | 
                 grep -v '^[+-]# Update time:' | grep -q '^[+-]'; then
                changes=true
                echo "发现变化: $file"
              fi
            done
            
            # 设置输出变量
            if [ "$changes" = true ]; then
              echo "has_changes=true" >> "$GITHUB_OUTPUT"
              echo "✨ 规则已更新，即将提交更改"
            else
              echo "has_changes=false" >> "$GITHUB_OUTPUT"
              echo "ℹ️ 规则无变化，无需提交"
              # 还原已暂存的文件
              git restore --staged "${rule_files[@]}" 2>/dev/null || true
            fi
          }

          # 启动程序
          main "$1"
          EOF
          
          chmod +x process_rules.sh
          echo "脚本创建完成"
          echo "::endgroup::"

      - name: Update RuleSets
        id: check_changes
        run: |
          echo "::group::开始更新规则集"
          echo "开始规则处理流程..."
          ./process_rules.sh "${{ env.RULES_CONFIG }}"
          echo "::endgroup::"

      - name: Commit and Push Changes
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          echo "::group::提交变更"
          echo "检测到规则变更，提交到仓库..."
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git commit -m "Auto update rules by action bot"
          
          # 显示本次提交的统计信息但不显示具体内容
          echo "本次更新统计:"
          git show --stat --oneline HEAD
          
          # 推送更改
          echo "推送更改到远程仓库..."
          git push
          echo "::endgroup::"
        env:
          GITHUB_TOKEN: ${{ github.token }}

      - name: Delete Workflow Runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ github.token }}
          repository: ${{ github.repository }}
          retain_days: 0
          keep_minimum_runs: 2  # 保留最近6次运行记录，便于查看历史
