name: Update Rules

on:
  schedule:
    - cron: '0 */3 * * *'
  workflow_dispatch:

env:
  RULE_CHINA_PATH: RuleSet/Direct/China.list
  RULE_CHINA_URLS: >-
    https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Surge/ChinaMax/ChinaMax_Domain.list
    https://raw.githubusercontent.com/Loyalsoldier/surge-rules/release/direct.txt
    https://raw.githubusercontent.com/vitoegg/Provider/master/RuleSet/Direct/LocalNet.list
  
  RULE_APPLE_PATH: RuleSet/Apple/Service.list
  RULE_APPLE_URLS: >-
    https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Surge/Apple/Apple_Domain.list
    https://raw.githubusercontent.com/Loyalsoldier/surge-rules/release/apple.txt
    https://raw.githubusercontent.com/Loyalsoldier/surge-rules/release/icloud.txt
  
  RULE_REJECT_PATH: RuleSet/Extra/Reject.list
  RULE_REJECT_URLS: >-
    https://ruleset.skk.moe/List/domainset/reject.conf
    https://ruleset.skk.moe/List/domainset/reject_extra.conf
    https://raw.githubusercontent.com/vitoegg/Provider/master/RuleSet/Extra/Privacy.list

jobs:
  update-rules:
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.check_changes.outputs.has_changes }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        id: checkout
        with:
          fetch-depth: 1

      - name: Setup Timezone
        run: sudo timedatectl set-timezone "Asia/Shanghai"
        id: timezone

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
        id: python

      - name: Create Processing Script
        id: create_script
        run: |
          cat > process_rules.sh << 'EOF'
          #!/bin/bash
          set -eo pipefail

          get_rules_config() {
            local -n rule_list="$1"
            local -n file_list="$2"
            
            echo "正在查找规则配置..."
            
            for var in $(env | grep "^RULE_.*_PATH=" | cut -d= -f1); do
              local rule_name=${var%_PATH}
              rule_name=${rule_name#RULE_}
              
              local url_var="RULE_${rule_name}_URLS"
              
              if [[ -v $url_var ]]; then
                local path=${!var}
                local urls=${!url_var}
                
                echo "找到规则: $rule_name"
                echo "- 保存路径: $path"
                echo "- 下载地址数量: $(echo "$urls" | wc -w)"
                
                rule_list["$rule_name"]="$path;$urls"
                file_list+=("$path")
              fi
            done
            
            echo "共找到 ${#rule_list[@]} 个规则"
          }

          process_rule() {
            local rule_name="$1"
            local output_path="$2"
            local urls="$3"
            
            local output_dir=$(dirname "$output_path")
            mkdir -p "$output_dir"
            
            echo "开始处理规则: $rule_name"
            echo "保存位置: $output_path"
            
            local start_time=$SECONDS
            
            echo "正在下载规则..."
            
            local merged_file=$(mktemp)
            local cleaned_file=$(mktemp)
            local tmp_dir=$(mktemp -d)
            
            local download_count=0
            local download_pids=()
            
            for url in $urls; do
              local tmp_file="${tmp_dir}/download_${download_count}"
              
              (curl -sL --fail --connect-timeout 10 --max-time 30 "$url" > "$tmp_file" && 
               echo "下载成功: $url" || 
               echo "下载失败: $url") &
              
              download_pids+=($!)
              download_count=$((download_count + 1))
            done
            
            for pid in "${download_pids[@]}"; do
              wait $pid
            done
            
            echo "正在合并和清理规则..."
            
            cat "${tmp_dir}"/download_* > "$merged_file"
            
            sed -e 's/[[:space:]]*[#;\/\/].*$//' \
                -e 's/^[[:space:]]*//;s/[[:space:]]*$//' \
                -e '/^$/d' \
                -e '/^[[:space:]]*[#;\/\/]/d' \
                -e '/^payload:/d' \
                -e '/^[[:space:]]*\/\*/d;/\*\//d' \
                "$merged_file" > "$cleaned_file"
            
            local cleaned_count=$(wc -l < "$cleaned_file")
            echo "清理后的规则数量: $cleaned_count"
            
            if [[ -s "$cleaned_file" ]]; then
              echo "正在使用高级算法排序和去除重复项..."
              
              local final_file=$(mktemp)
              
              echo "使用智能规则优化脚本处理..."
              
              script_path="${GITHUB_WORKSPACE}/Script/Workflow/process_rules.py"
              chmod +x "$script_path"
              
              local stats_file=$(mktemp)
              
              python3 "$script_path" "$cleaned_file" > "$final_file" 2> "$stats_file"
              python_exit=$?
              
              if [ $python_exit -ne 0 ]; then
                echo "Python脚本执行失败，回退到基础排序和去重"
                echo "错误信息: $(cat "$stats_file")"
                sort -u "$cleaned_file" > "$final_file"
              else
                cat "$stats_file"
                echo "智能优化完成"
              fi
              
              rm -f "$stats_file"
              
              local final_count=$(wc -l < "$final_file")
              local removed_count=$((cleaned_count - final_count))
              echo "去重后的规则数量: $final_count (减少了 $removed_count 个重复项)"
              
              echo "正在生成最终规则文件..."
              
              local meta_file=$(mktemp)
              
              {
                echo "# 规则来源:"
                for url in $urls; do
                  repo_url=$(echo "$url" | sed -E 's|raw.githubusercontent.com/([^/]+/[^/]+).*|github.com/\1|')
                  echo "# - https://$repo_url"
                done
                echo ""
                cat "$final_file"
              } > "$meta_file"
              
              local changed=0
              local new_rules_count=$(grep -v "^#" "$meta_file" | wc -l)
              local old_rules_count=0
              local added_rules=0
              local removed_rules=0
              
              echo "最新规则文件包含 $new_rules_count 条规则"
              
              if [ -f "$output_path" ]; then
                local old_file=$(mktemp)
                grep -v "^# Update time:" "$output_path" > "$old_file"
                
                old_rules_count=$(grep -v "^#" "$old_file" | wc -l)
                echo "仓库已有规则文件包含 $old_rules_count 条规则"
                
                # 比较实际规则内容而不是整个文件
                local old_rules_content=$(mktemp)
                local new_rules_content=$(mktemp)
                
                # 提取并排序规则内容进行比较
                grep -v "^#" "$old_file" | sort > "$old_rules_content"
                grep -v "^#" "$meta_file" | sort > "$new_rules_content"
                
                if ! cmp -s "$old_rules_content" "$new_rules_content"; then
                  changed=1
                  
                  # 创建临时文件存储规则 (不含注释)
                  local old_rules="$old_rules_content"
                  local new_rules="$new_rules_content"
                  
                  # 计算新增的规则
                  local added_rules_file=$(mktemp)
                  comm -23 "$new_rules" "$old_rules" > "$added_rules_file"
                  added_rules=$(wc -l < "$added_rules_file")
                  
                  # 计算删除的规则
                  local removed_rules_file=$(mktemp)
                  comm -13 "$new_rules" "$old_rules" > "$removed_rules_file"
                  removed_rules=$(wc -l < "$removed_rules_file")
                  
                  echo "规则变化详情:"
                  echo "- 新增规则: $added_rules 条"
                  echo "- 删除规则: $removed_rules 条"
                  
                  if [ $added_rules -gt 0 ]; then
                    echo "新增规则列表:"
                    cat "$added_rules_file"
                  fi
                  
                  if [ $removed_rules -gt 0 ]; then
                    echo "删除规则列表:"
                    cat "$removed_rules_file"
                  fi
                  
                  # 清理临时文件
                  rm -f "$old_rules_content" "$new_rules_content" "$added_rules_file" "$removed_rules_file"
                else
                  echo "规则对比: 内容完全相同，无变化"
                  # 清理临时文件
                  rm -f "$old_rules_content" "$new_rules_content"
                fi
                rm -f "$old_file"
              else
                changed=1
                added_rules=$new_rules_count
                echo "新建规则文件，新增 $added_rules 条规则"
              fi
              
              # 总结规则状态
              echo "规则状态摘要:"
              echo "- 文件: $(basename "$output_path")"
              echo "- 最新规则数量: $new_rules_count"
              echo "- 仓库规则数量: $old_rules_count"
              echo "- 增加规则数量: $added_rules"
              echo "- 删除规则数量: $removed_rules"
              echo "- 是否有变更: $([ $changed -eq 1 ] && echo '是' || echo '否')"
              
              if [ $changed -eq 1 ]; then
                {
                  echo "# Update time: $(date '+%Y-%m-%d %H:%M:%S')"
                  cat "$meta_file"
                } > "$output_path"
                echo "规则已更新"
              else
                echo "规则无变化，无需更新"
              fi
              
              rm -f "$final_file" "$meta_file"
            else
              echo "警告: 没有找到有效内容，跳过处理"
            fi
            
            rm -f "$merged_file" "$cleaned_file"
            rm -rf "$tmp_dir"
            
            local duration=$((SECONDS - start_time))
            echo "处理用时: $duration 秒"
          }

          main() {
            echo "===== 网络规则更新程序 ====="
            echo "开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "============================"
            
            declare -A rule_configs
            declare -a rule_files
            
            get_rules_config rule_configs rule_files
            
            if [ ${#rule_configs[@]} -eq 0 ]; then
              echo "没有找到规则配置，程序结束"
              return
            fi
            
            echo "============================"
            echo "开始更新规则"
            echo "============================"
            
            local start_time=$SECONDS
            
            for rule_name in "${!rule_configs[@]}"; do
              IFS=';' read -r output_path urls <<< "${rule_configs[$rule_name]}"
              
              echo "============================"
              process_rule "$rule_name" "$output_path" "$urls"
              echo "============================"
            done
            
            local duration=$((SECONDS - start_time))
            echo "所有规则处理完成"
            echo "总用时: $((duration / 60))分$((duration % 60))秒"
            
            local has_changes=false
            local change_summary=""
            local total_added=0
            local total_removed=0
            
            # 将所有规则文件添加到暂存区以检查变化
            git add "${rule_files[@]}" 2>/dev/null || true
            
            echo "============================"
            echo "规则变更汇总报告"
            echo "============================"
            
            for file in "${rule_files[@]}"; do
              if [ -f "$file" ]; then
                local diff_file=$(mktemp)
                git diff --cached --no-color "$file" > "$diff_file"
                
                local file_changed=false
                
                # 检查是否有非更新时间的变化
                if grep -v '^[+-]# Update time:' "$diff_file" | grep -q '^[+-]'; then
                  file_changed=true
                  has_changes=true
                  local basename=$(basename "$file")
                  
                  # 从文件中分离规则（不含注释）进行比较
                  local new_rules_only=$(mktemp)
                  local old_rules_only=$(mktemp)
                  
                  # 计算新文件中的规则
                  grep -v '^#' "$file" | sort > "$new_rules_only"
                  
                  # 获取暂存区的文件内容以计算旧文件中的规则
                  local old_file_content=$(mktemp)
                  git show HEAD:"$file" > "$old_file_content" 2>/dev/null || touch "$old_file_content"
                  grep -v '^#' "$old_file_content" | sort > "$old_rules_only"
                  
                  # 计算新增的规则
                  local added_rules_file=$(mktemp)
                  comm -23 "$new_rules_only" "$old_rules_only" > "$added_rules_file"
                  local added_lines=$(wc -l < "$added_rules_file")
                  
                  # 计算删除的规则
                  local removed_rules_file=$(mktemp)
                  comm -13 "$new_rules_only" "$old_rules_only" > "$removed_rules_file"
                  local removed_lines=$(wc -l < "$removed_rules_file")
                  
                  # 计算规则数量
                  local new_count=$(wc -l < "$new_rules_only")
                  local old_count=$(wc -l < "$old_rules_only")
                  
                  echo "文件: $basename"
                  echo "- 最新规则数量: $new_count"
                  echo "- 仓库规则数量: $old_count"
                  echo "- 增加规则数量: $added_lines"
                  echo "- 删除规则数量: $removed_lines"
                  echo "- 是否有变更: 是"
                  
                  # 提取规则类型名称 (去掉.list后缀)
                  local rule_name=$(basename "$file" .list)
                  change_summary="${change_summary}${rule_name}(+${added_lines}/-${removed_lines}) "
                  
                  total_added=$((total_added + added_lines))
                  total_removed=$((total_removed + removed_lines))
                  
                  # 清理临时文件
                  rm -f "$new_rules_only" "$old_rules_only" "$added_rules_file" "$removed_rules_file" "$old_file_content"
                else
                  # 没有变化的情况
                  local new_count=$(grep -v '^#' "$file" | wc -l)
                  local basename=$(basename "$file")
                  
                  echo "文件: $basename"
                  echo "- 规则数量: $new_count"
                  echo "- 是否有变更: 否"
                fi
                
                rm -f "$diff_file"
              fi
            done
            
            echo "============================"
            
            if [ "$has_changes" = true ]; then
              # 移除末尾的空格
              change_summary=$(echo "$change_summary" | sed 's/ $//')
              echo "新的commit信息: Update rules: $change_summary"
              
              if [ -n "$GITHUB_OUTPUT" ]; then
                echo "has_changes=true" >> $GITHUB_OUTPUT
                echo "change_summary=${change_summary}" >> $GITHUB_OUTPUT
              fi
            else
              echo "总结: 所有规则文件均无变化"
              
              if [ -n "$GITHUB_OUTPUT" ]; then
                echo "has_changes=false" >> $GITHUB_OUTPUT
              fi
              # 如果没有变化，恢复暂存区
              git restore --staged "${rule_files[@]}" 2>/dev/null || true
            fi
          }

          main
          EOF
          
          chmod +x process_rules.sh

      - name: Update RuleSets
        id: check_changes
        run: ./process_rules.sh

      - name: Commit and Push Changes
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git commit -m "Update rules: ${{ steps.check_changes.outputs.change_summary }}"
          git push
        env:
          GITHUB_TOKEN: ${{ github.token }}

      - name: Delete Workflow Runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ github.token }}
          repository: ${{ github.repository }}
          retain_days: 0
          keep_minimum_runs: 2