name: Update Rules

on:
  schedule:
    - cron: '0 */3 * * *'  # 每3小时执行一次
  workflow_dispatch:

env:
  RULES_CONFIG: |
    rules:
      China:
        path: RuleSet/Direct/China.list
        urls:
          - https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Surge/ChinaMax/ChinaMax_Domain.list
          - https://raw.githubusercontent.com/Loyalsoldier/surge-rules/release/direct.txt
          - https://raw.githubusercontent.com/vitoegg/Provider/master/RuleSet/Direct/LocalNet.list
      
      Apple:
        path: RuleSet/Apple/Service.list
        urls:
          - https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Surge/Apple/Apple_Domain.list
          - https://raw.githubusercontent.com/Loyalsoldier/surge-rules/release/apple.txt
          - https://raw.githubusercontent.com/Loyalsoldier/surge-rules/release/icloud.txt
      
      Reject:
        path: RuleSet/Extra/Reject.list
        urls:
          - https://ruleset.skk.moe/List/domainset/reject.conf
          - https://ruleset.skk.moe/List/domainset/reject_extra.conf
          - https://raw.githubusercontent.com/vitoegg/Provider/master/RuleSet/Extra/Privacy.list

jobs:
  update-rules:
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.check_changes.outputs.has_changes }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Timezone
        run: sudo timedatectl set-timezone "Asia/Shanghai"

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Create Processing Script
        run: |
          # 创建高效处理脚本
          cat > process_rules.sh << 'EOF'
          #!/bin/bash
          set -eo pipefail

          # 解析规则配置
          parse_rules_config() {
            local config="$1"
            local -n rule_configs_ref="$2"
            local -n rule_files_ref="$3"

            local rule_name=""
            local path=""
            local urls=""

            while IFS= read -r line; do
              # 跳过空行和注释
              [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

              if [[ "$line" =~ ^[[:space:]]*([^:]+):[[:space:]]*$ ]]; then
                rule_name="${BASH_REMATCH[1]}"
                if [[ "$rule_name" != "rules" ]]; then
                  path=""
                  urls=""
                fi
              elif [[ "$line" =~ ^[[:space:]]*path:[[:space:]]*([^[:space:]]+) ]]; then
                path="${BASH_REMATCH[1]}"
                rule_files_ref+=("$path")
              elif [[ "$line" =~ ^[[:space:]]*urls:[[:space:]]*$ ]]; then
                continue
              elif [[ "$line" =~ ^[[:space:]]*-[[:space:]]*([^[:space:]]+) ]]; then
                urls+="${BASH_REMATCH[1]} "
              elif [[ -n "$rule_name" && -n "$path" && -n "$urls" ]]; then
                rule_configs_ref["$rule_name"]="$path;$urls"
                rule_name=""
              fi
            done <<< "$config"

            # 检查最后一个规则
            if [[ -n "$rule_name" && -n "$path" && -n "$urls" && "$rule_name" != "rules" ]]; then
              rule_configs_ref["$rule_name"]="$path;$urls"
            fi
          }

          # 下载并处理规则
          process_rule() {
            local rule_name="$1"
            local output_path="$2"
            local urls="$3"
            local output_dir
            output_dir=$(dirname "$output_path")
            
            echo "Processing $rule_name to $output_path..."

            # 创建输出目录
            mkdir -p "$output_dir"
            
            # 临时文件
            local merged_file
            local cleaned_file
            merged_file=$(mktemp)
            cleaned_file=$(mktemp)
            
            # 下载和合并规则
            echo "" > "$merged_file"
            for url in $urls; do
              echo "Downloading from $url..."
              if curl -sL --fail "$url" >> "$merged_file"; then
                echo "  Download successful"
              else
                echo "  Download failed, skipping"
              fi
            done
            
            # 快速清理文件 (移除注释、空行和前缀)
            grep -v "^#" "$merged_file" | grep -v "^$" | grep -v "^payload:" > "$cleaned_file" || true
            
            # 仅当有内容时才处理域名
            if [[ -s "$cleaned_file" ]]; then
              # 处理格式
              local formatted_file
              formatted_file=$(mktemp)
              
              sed -E 's/[[:space:]]*#.*$//' "$cleaned_file" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g' | sort | uniq > "$formatted_file"
              
              # 创建最终输出文件
              local final_file
              final_file=$(mktemp)
              
              # 根据文件类型添加头部
              {
                if [[ "$output_path" == *.yaml ]]; then
                  echo "payload:"
                fi
                
                # 处理域名关系
                # 高效过滤域名：创建反向索引，检查子域名关系
                awk '
                BEGIN {
                  IGNORECASE = 1  # 忽略大小写
                }
                {
                  # 提取域名部分
                  domain = $0
                  gsub(/^[^:]+:[[:space:]]*/, "", domain)
                  
                  # 存储域名信息
                  if (length(domain) > 0) {
                    domains[domain] = $0
                    count++
                  }
                }
                END {
                  if (count > 0) {
                    # 创建排序数组
                    n = asort(domains, sorted_domains, "@val_str_asc")
                    
                    # 进行单次遍历
                    for (i = 1; i <= n; i++) {
                      current = sorted_domains[i]
                      if (length(current) > 0) {
                        keep = 1
                        
                        # 提取域名
                        current_domain = current
                        gsub(/^[^:]+:[[:space:]]*/, "", current_domain)
                        
                        # 快速域名检测
                        for (j = 1; j <= n; j++) {
                          if (i != j) {
                            other = sorted_domains[j]
                            other_domain = other
                            gsub(/^[^:]+:[[:space:]]*/, "", other_domain)
                            
                            # 检查是否为子域名
                            if (length(current_domain) < length(other_domain) && 
                                index(other_domain, current_domain) == 1 && 
                                substr(other_domain, length(current_domain) + 1, 1) == ".") {
                              keep = 0
                              break
                            }
                          }
                        }
                        
                        if (keep) {
                          print current
                        }
                      }
                    }
                  }
                }
                ' "$formatted_file"
              } > "$final_file"
              
              # 创建带有元数据的版本
              local meta_file
              meta_file=$(mktemp)
              
              {
                echo "# Merged from:"
                for url in $urls; do
                  repo_url=$(echo "$url" | sed -E 's|raw.githubusercontent.com/([^/]+/[^/]+).*|github.com/\1|')
                  echo "# - https://$repo_url"
                done
                echo ""
                cat "$final_file"
              } > "$meta_file"
              
              # 检查是否有更改
              local changed=0
              if [ -f "$output_path" ]; then
                local old_file
                old_file=$(mktemp)
                grep -v "^# Update time:" "$output_path" > "$old_file"
                
                if ! cmp -s "$old_file" "$meta_file"; then
                  changed=1
                fi
                rm -f "$old_file"
              else
                changed=1
              fi
              
              # 如果有更改，写入新文件
              if [ $changed -eq 1 ]; then
                {
                  echo "# Update time: $(date '+%Y-%m-%d %H:%M:%S')"
                  cat "$meta_file"
                } > "$output_path"
                echo "Changes detected in $rule_name rules."
              else
                echo "No changes detected in $rule_name rules."
              fi
              
              # 清理临时文件
              rm -f "$formatted_file" "$final_file" "$meta_file"
            else
              echo "Warning: No valid content for $rule_name"
            fi
            
            # 清理主要临时文件
            rm -f "$merged_file" "$cleaned_file"
          }

          # 主函数
          main() {
            local config="$1"
            
            # 初始化数据结构
            declare -A rule_configs
            declare -a rule_files
            
            # 解析配置
            parse_rules_config "$config" rule_configs rule_files
            
            # 处理每个规则
            for rule in "${!rule_configs[@]}"; do
              IFS=';' read -r output_path urls <<< "${rule_configs[$rule]}"
              process_rule "$rule" "$output_path" "$urls"
            done
            
            # 检查Git变更
            local changes_detected=false
            
            git add "${rule_files[@]}" 2>/dev/null || true
            
            for file in "${rule_files[@]}"; do
              if [ -f "$file" ] && git diff --cached --no-color "$file" | grep -v '^[+-]# Update time:' | grep -q '^[+-]'; then
                changes_detected=true
                break
              fi
            done
            
            # 输出结果
            if [ "$changes_detected" = true ]; then
              echo "has_changes=true" >> "$GITHUB_OUTPUT"
              echo "Changes detected in rules files"
            else
              echo "has_changes=false" >> "$GITHUB_OUTPUT"
              echo "No changes detected in rules files"
              git restore --staged "${rule_files[@]}" 2>/dev/null || true
            fi
          }

          # 运行主函数
          main "$1"
          EOF
          
          chmod +x process_rules.sh

      - name: Update RuleSets
        id: update_rules
        run: |
          ./process_rules.sh "${{ env.RULES_CONFIG }}"

      - name: Commit and Push Changes
        if: steps.update_rules.outputs.has_changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git commit -m "Auto update rules by action bot"
          git push
        env:
          GITHUB_TOKEN: ${{ github.token }}

      - name: Delete Workflow Runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ github.token }}
          repository: ${{ github.repository }}
          retain_days: 0
          keep_minimum_runs: 0
